
========== src/constants/contracts.ts ==========
import predictionABI from '../abi/prediction.json';

export const CONTRACTS = {
    prediction: {
      address: '0xafF9Ea1f907083706818d9411e1903351766C4d2',
      abi: predictionABI,
    },
  };
  
========== src/components/ConnectWalletButton.tsx ==========
// src/components/ConnectWalletButton.tsx
import React, { useEffect } from 'react';
import { Wallet } from 'lucide-react';
import { createAppKit } from '@reown/appkit';
import { useAccount } from 'wagmi';
import { polygon } from '@reown/appkit/networks';

// Import the same wagmiAdapter from main.tsx
import { wagmiAdapter } from '@/main';

interface ConnectWalletButtonProps {
  className?: string;
  onConnectionSuccess: () => void;
}

export const ConnectWalletButton: React.FC<ConnectWalletButtonProps> = ({
  className = '',
  onConnectionSuccess,
}) => {
  /**
   * Create a Reown modal with the same wagmiAdapter.
   * Remove or rename any properties that your TS definitions don't allow
   * (such as 'modalConfig' or 'autoConnect' or 'connectMethodsOrder').
   */
  const modal = createAppKit({
    adapters: [wagmiAdapter],
    networks: [polygon],
    projectId: '9ba0d4ac5db061b3efb559c91eabfef5',
    metadata: {
      name: 'ProfitFlip',
      description: 'Prediction App',
      url: 'https://profitflip.online',
      icons: ['https://assets.reown.com/reown-profile-pic.png'],
    },
    features: {
      analytics: true,
      connectMethodsOrder: ['wallet'],
    }
  });

  // Wagmi's built-in hook to see if the user is connected
  const { isConnected } = useAccount();

  // Once wagmi sees `isConnected = true`, notify the parent
  useEffect(() => {
    if (isConnected) {
      onConnectionSuccess();
    }
  }, [isConnected, onConnectionSuccess]);

  return (
    <button
      onClick={() => modal.open()}
      className={`flex items-center justify-center gap-2 bg-indigo-600 text-white py-3 px-4 rounded-lg hover:bg-indigo-700 transition-colors ${className}`}
    >
      <Wallet className="w-5 h-5" />
      Connect Wallet
    </button>
  );
};

========== src/components/PredictionCard.tsx ==========
// PredictionCard.tsx
import React from 'react';
import { ArrowUp, ArrowDown } from 'lucide-react';
import { ConnectWalletButton } from './ConnectWalletButton';
// Example utility function if you have “cn” in "src/utils/cn.ts"
import { cn } from '@/utils/cn';

// Reintroduce the props for stats
interface PredictionCardProps {
  title: string;
  amount: string;        // minimal bet
  currentPrice: string;  // current price
  players: string;
  timeLeft: string;
  isConnected: boolean;
  onConnect: () => void;
  onPredictUp: () => Promise<void>;
  onPredictDown: () => Promise<void>;
}

export const PredictionCard: React.FC<PredictionCardProps> = ({
  title,
  amount,
  currentPrice,
  players,
  timeLeft,
  isConnected,
  onConnect,
  onPredictUp,
  onPredictDown,
}) => {
  return (
    <div
      className={cn(
        'w-[358px] h-[580px] max-w-sm mx-auto flex flex-col overflow-hidden bg-white rounded-2xl p-4 shadow-lg border relative'
      )}
    >
      {/* Bring back the decorative blobs if you want */}
      {/* <CardDecoration /> */}

      <h2 className="text-xl font-bold text-center mb-6">{title}</h2>

      {/* Example Stats Section */}
      <div className="flex-grow">
        <div className="mt-4 space-y-3">
          <CardStat label="Minimal Bet" value={`${amount} POL`} color="orange" />
          <CardStat
            label="Current Price"
            value={`₿ ${currentPrice}`}
            color="green"
          />
          <CardStat label="Players" value={players} color="orange" />
          <CardStat label="Time Left" value={timeLeft} color="green" />
        </div>
      </div>

      <div className="mt-auto">
        {!isConnected ? (
          <ConnectWalletButton
            className="w-full"
            onConnectionSuccess={onConnect}
          />
        ) : (
          <div className="grid grid-cols-2 gap-2">
            <button
              onClick={onPredictDown}
              className="bg-red-500 hover:bg-red-600 text-white py-2 rounded-lg flex items-center justify-center text-sm font-medium"
            >
              <ArrowDown className="w-4 h-4 mr-1.5" />
              Down
            </button>
            <button
              onClick={onPredictUp}
              className="bg-emerald-500 hover:bg-emerald-600 text-white py-2 rounded-lg flex items-center justify-center text-sm font-medium"
            >
              <ArrowUp className="w-4 h-4 mr-1.5" />
              Up
            </button>
          </div>
        )}
      </div>
    </div>
  );
};

// Example decorative blobs
const CardDecoration = () => (
  <>
    <style>
      {`
        @keyframes blob {
          0% { transform: translate(0, 0) scale(1); }
          33% { transform: translate(30px, -50px) scale(1.1); }
          66% { transform: translate(-20px, 20px) scale(0.9); }
          100% { transform: translate(0, 0) scale(1); }
        }
        .animate-blob { animation: blob 7s infinite; }
        .delay-2s { animation-delay: 2s; }
        .delay-4s { animation-delay: 4s; }
      `}
    </style>
    <div className="absolute inset-0 pointer-events-none z-0">
      <div className="absolute -top-40 -left-40 w-80 h-80 bg-orange-200 rounded-full mix-blend-multiply filter blur-xl opacity-70 animate-blob" />
      <div className="absolute -bottom-40 -right-40 w-80 h-80 bg-emerald-200 rounded-full mix-blend-multiply filter blur-xl opacity-70 animate-blob delay-2s" />
      <div className="absolute top-40 right-20 w-80 h-80 bg-yellow-200 rounded-full mix-blend-multiply filter blur-xl opacity-70 animate-blob delay-4s" />
    </div>
  </>
);

// Simple stat component
const CardStat: React.FC<{
  label: string;
  value: string;
  color: 'orange' | 'green';
}> = ({ label, value, color }) => (
  <div
    className={cn(
      'p-2 rounded border text-sm',
      color === 'orange'
        ? 'bg-orange-50 border-orange-200'
        : 'bg-emerald-50 border-emerald-200'
    )}
  >
    <div className="text-xs text-gray-600 font-medium mb-1">{label}</div>
    <div className="text-sm font-bold text-gray-900">{value}</div>
  </div>
);

========== src/components/usePredictionGame.tsx ==========
import { useEffect, useState, useCallback } from 'react';
import { ethers } from 'ethers';
import { CONTRACTS } from '@/constants/contracts';

const CONTRACT_ADDRESS = CONTRACTS.prediction.address;

const AggregatorV3InterfaceABI = [
  "function latestRoundData() view returns (uint80, int256, uint256, uint256, uint80)"
];

const ABI = CONTRACTS.prediction.abi;

export const usePredictionGame = () => {
  const [contract, setContract] = useState<ethers.Contract | null>(null);
  const [epoch, setEpoch] = useState<number | null>(null);
  const [price, setPrice] = useState<string>('0');
  const [minBet, setMinBet] = useState<string>('0');
  const [paused, setPaused] = useState<boolean>(false);

  useEffect(() => {
    if (!window.ethereum) return;
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const signer = provider.getSigner();
    const instance = new ethers.Contract(CONTRACT_ADDRESS, ABI, signer);
    setContract(instance);
  }, []);

  const refreshGameState = useCallback(async () => {
    if (!contract) return;
    try {
      const [epochRaw, minBetRaw, pausedStatus] = await Promise.all([
        contract.currentEpoch(),
        contract.minBetAmount(),
        contract.paused()
      ]);
      setEpoch(epochRaw.toNumber());
      setMinBet(ethers.utils.formatEther(minBetRaw));
      setPaused(pausedStatus);

      const oracleAddress = await contract.oracle();
      const oracle = new ethers.Contract(oracleAddress, AggregatorV3InterfaceABI, contract.provider);
      const [, rawPrice] = await oracle.latestRoundData();
      setPrice(ethers.utils.formatUnits(rawPrice, 8));
    } catch (err) {
      console.error("Error fetching game state:", err);
    }
  }, [contract]);

  const placeBet = useCallback(async (direction: 'bull' | 'bear', amountEth: string) => {
    if (!contract || epoch === null) return;
    const fn = direction === 'bull' ? 'betBull' : 'betBear';
    const tx = await contract[fn](epoch, {
      value: ethers.utils.parseEther(amountEth)
    });
    await tx.wait();
  }, [contract, epoch]);

  useEffect(() => {
    if (contract) refreshGameState();
  }, [contract, refreshGameState]);

  return {
    epoch,
    price,
    minBet,
    paused,
    placeBet,
    refreshGameState,
  };
};

========== src/App.tsx ==========
// src/App.tsx
import React, { useState } from 'react';
import { Toaster, toast } from 'react-hot-toast';
import { PredictionCard } from '@/components/PredictionCard';

const App: React.FC = () => {
  const [isConnected, setIsConnected] = useState(false);

  const handleConnect = () => {
    setIsConnected(true);
    toast.success('Wallet connected!');
  };

  const predictUp = async () => {
    if (!isConnected) {
      toast.error('Please connect your wallet first');
      return;
    }
    // ... do contract calls or any logic ...
  };

  const predictDown = async () => {
    if (!isConnected) {
      toast.error('Please connect your wallet first');
      return;
    }
    // ... do contract calls or any logic ...
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-orange-50 to-emerald-50 flex items-center justify-center p-4">
      <PredictionCard
        title="BTC/USD"
        amount = "0.0001"
        currentPrice = "78000"
        players = "128"
        timeLeft = "3m"
        isConnected={isConnected}
        onConnect={handleConnect}
        onPredictUp={predictUp}
        onPredictDown={predictDown}
      />
      <Toaster position="bottom-right" />
    </div>
  );
};

export default App;

========== src/main.tsx ==========
// src/main.tsx

import React from 'react';
import ReactDOM from 'react-dom/client';

// Wagmi imports (older versions typically have just WagmiConfig)
import { WagmiConfig } from 'wagmi';

// Reown adapter
import { WagmiAdapter } from '@reown/appkit-adapter-wagmi';
import { mainnet, polygon } from '@reown/appkit/networks';

import App from './App';
import './index.css'; // If you have Tailwind/global styles

/**
 * 1) Create ONE WagmiAdapter for the entire app.
 */
export const wagmiAdapter = new WagmiAdapter({
  projectId: '9ba0d4ac5db061b3efb559c91eabfef5',
  networks: [mainnet, polygon],
});

/**
 * 2) Some older versions expose the wagmi client as `client`
 *    If yours is different (e.g. `wagmiAdapter.config`), replace below.
 */
const { wagmiConfig } = wagmiAdapter;

/**
 * 3) Wrap <App /> in <WagmiConfig> only if we have a wagmi config.
 *    If wagmiConfig is undefined or not recognized, you can skip <WagmiConfig>.
 */
ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    {wagmiConfig ? (
      <WagmiConfig config={wagmiConfig}>
        <App />
      </WagmiConfig>
    ) : (
      <App />
    )}
  </React.StrictMode>
);

========== END ==========




